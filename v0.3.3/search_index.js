var documenterSearchIndex = {"docs":
[{"location":"charts/#Charts","page":"Charts","title":"Charts","text":"","category":"section"},{"location":"charts/","page":"Charts","title":"Charts","text":"Charts represent maps from parameter domains to configuration space. Their main use is to provide the geometric description of the cells that make up meshes.","category":"page"},{"location":"charts/","page":"Charts","title":"Charts","text":"The Chart concept is defined by the following API","category":"page"},{"location":"charts/","page":"Charts","title":"Charts","text":"dimension(ch::CompScienceMeshes.Simplex)\nuniversedimension\nvolume(::CompScienceMeshes.Simplex)\nneighborhood","category":"page"},{"location":"charts/#CompScienceMeshes.dimension-Tuple{CompScienceMeshes.Simplex}","page":"Charts","title":"CompScienceMeshes.dimension","text":"dimension(simplex)\n\nReturn the manifold dimension of the simplex.\n\n\n\n\n\n","category":"method"},{"location":"charts/#CompScienceMeshes.universedimension","page":"Charts","title":"CompScienceMeshes.universedimension","text":"universedimension(mesh)\n\nReturns the dimension of the surrounding space. Equals the number of coordinates required to describe a vertex.\n\n\n\n\n\nuniversedimension(p)\n\nReturn the dimension of the universe in which p is embedded.\n\n\n\n\n\n","category":"function"},{"location":"charts/#CompScienceMeshes.volume-Tuple{CompScienceMeshes.Simplex}","page":"Charts","title":"CompScienceMeshes.volume","text":"volume(simplex)\n\nReturn the volume of the simplex.\n\n\n\n\n\n","category":"method"},{"location":"charts/#CompScienceMeshes.neighborhood","page":"Charts","title":"CompScienceMeshes.neighborhood","text":"neighborhood(chart, params)\n\nCreate a neighborhood from a chart and a set of parameter values.\n\n\n\n\n\n","category":"function"},{"location":"charts/","page":"Charts","title":"Charts","text":"The most important example of a Chart is a Simplex. For Simplices, the following additional functions are available","category":"page"},{"location":"charts/","page":"Charts","title":"Charts","text":"simplex\ncenter","category":"page"},{"location":"charts/#CompScienceMeshes.simplex","page":"Charts","title":"CompScienceMeshes.simplex","text":"simplex(vertices)\nsimplex(v1, v2, ...)\nsimplex(vertices, Val{D})\n\nBuild a D-dimensional simplex. The vertices can be passed in an array (static or dynamic), or supplied separately. If the length of the array is not part of its type, the speed of the construction can be improved by supplying an extra Val{D} argument. In case it is not clear from the context whether the vertex array is dynamically or statically sized, use the third form as it will not incur notable performance hits.\n\nNote that D is the dimension of the simplex, i.e. the number of vertices supplied minus one.\n\n\n\n\n\n","category":"function"},{"location":"charts/#CompScienceMeshes.center","page":"Charts","title":"CompScienceMeshes.center","text":"center(simplex) -> neighborhood\n\nCreate the neighborhood at the center of the simplex, i.e. the point corresponding to parameter (1/(D+1), 1/(D+1), ...) where D is the simplex dimension.\n\n\n\n\n\n","category":"function"},{"location":"neighborhood/#Neighborhoods","page":"Neighborhoods","title":"Neighborhoods","text":"","category":"section"},{"location":"neighborhood/","page":"Neighborhoods","title":"Neighborhoods","text":"The Neighborhood concept represents the differential geometric notion of the derivative of a chart in a point of its parameter domain. Not only can it be queried for the parametric and Cartesian coordinates of the input and output point respectively, it also contains information on tangents and Jacobian determinants. For the special case where the dimension of the range manifold is one less than that of the surrounding space, access is provided to the unit normal.","category":"page"},{"location":"neighborhood/","page":"Neighborhoods","title":"Neighborhoods","text":"This concept is an enriched point concept and should allow the construction of the majority of kernels encountered in finite and boundary element methods.","category":"page"},{"location":"neighborhood/","page":"Neighborhoods","title":"Neighborhoods","text":"parametric\ncartesian\njacobian\ntangents\nnormal","category":"page"},{"location":"neighborhood/#CompScienceMeshes.parametric","page":"Neighborhoods","title":"CompScienceMeshes.parametric","text":"parametric(neighborhood) -> point\n\nReturn the parameters where neighborhood is located.\n\n\n\n\n\n","category":"function"},{"location":"neighborhood/#CompScienceMeshes.cartesian","page":"Neighborhoods","title":"CompScienceMeshes.cartesian","text":"cartesian(neighborhood) -> point\n\nReturn the cartesian coordinates of the point where neighborhood is located.\n\n\n\n\n\n","category":"function"},{"location":"neighborhood/#CompScienceMeshes.jacobian","page":"Neighborhoods","title":"CompScienceMeshes.jacobian","text":"A number defines a neighborhood in euclidian space\n\n\n\n\n\n","category":"function"},{"location":"neighborhood/#CompScienceMeshes.tangents","page":"Neighborhoods","title":"CompScienceMeshes.tangents","text":"tangents(splx)\n\nReturns a matrix whose columns are the tangents of the simplex splx.\n\n\n\n\n\ntangents(neighborhod, i) -> tangent_i\n\nReturn the i-th tangent vector at the neighborhood.\n\n\n\n\n\n","category":"function"},{"location":"neighborhood/#CompScienceMeshes.normal","page":"Neighborhoods","title":"CompScienceMeshes.normal","text":"normal(neighborhood)\n\nReturn the normal at a neighborhood on a surface.\n\n\n\n\n\n","category":"function"},{"location":"neighborhood/","page":"Neighborhoods","title":"Neighborhoods","text":"In addition to this interface, a neighborhood has appropriate methods for getindex defined, so that it can be used with any function that expects a tuple of coordinates. In other words, a neighborhood is a model for Point.","category":"page"},{"location":"neighborhood/#Numerical-Quadrature","page":"Neighborhoods","title":"Numerical Quadrature","text":"","category":"section"},{"location":"neighborhood/","page":"Neighborhoods","title":"Neighborhoods","text":"This package provides a number of routines that aim to facilitate numerical quadrature over charts. In addition, it includes a default set of quadrature rules for segments (1D) and triangles (2D).","category":"page"},{"location":"neighborhood/","page":"Neighborhoods","title":"Neighborhoods","text":"quadpoints","category":"page"},{"location":"neighborhood/#CompScienceMeshes.quadpoints","page":"Neighborhoods","title":"CompScienceMeshes.quadpoints","text":"pw = quadpoints(chart, rule)\n\nReturns a collection of (point, weight) tuples corresponding to the numerical quadrature rule defined on the domain of chart. The weights returned take into account the Jacobian determinant resulting from mapping from the reference domain to the configuration space.\n\nFunctions can be integrated like:\n\nPW = quadpoints(chart, rule)\nI = sum(pw[2]*f(pw[1]) for pw in PW)\n\n\n\n\n\nquadpoints(refspace, charts, rules)\n\nComputed a matrix of vectors containing (weight, point, value) triples that can be used in numerical integration over the elements described by the charts. Internally, this method used quadpoints(chart, rule) to retrieve the points and weights for a certain quadrature rule over chart.\n\n\n\n\n\n","category":"function"},{"location":"#CompScienceMeshes.jl","page":"CompScienceMeshes.jl","title":"CompScienceMeshes.jl","text":"","category":"section"},{"location":"","page":"CompScienceMeshes.jl","title":"CompScienceMeshes.jl","text":"Meshes, charts, and differential geometry for finite and boundary element solvers.","category":"page"},{"location":"#Installation","page":"CompScienceMeshes.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"CompScienceMeshes.jl","title":"CompScienceMeshes.jl","text":"In addition to the dependencies declared in REQUIRE, this package relies for some of its functionality on gmsh. Make sure gmsh is installed and on the system path if you require this functionality.","category":"page"},{"location":"#Introduction","page":"CompScienceMeshes.jl","title":"Introduction","text":"","category":"section"},{"location":"","page":"CompScienceMeshes.jl","title":"CompScienceMeshes.jl","text":"This package provides the geometric framework to facilitated the construction of finite element spaces and the assembly of matrices stemming from the discretisation of local (differential) and global (integral) operators on those finite element spaces.","category":"page"},{"location":"","page":"CompScienceMeshes.jl","title":"CompScienceMeshes.jl","text":"The package roughly contains three components:","category":"page"},{"location":"","page":"CompScienceMeshes.jl","title":"CompScienceMeshes.jl","text":"Meshes: allowing for the (almost) linear construction of connectivity matrices. A default implementation is provided but the algorithms should be easily extendable to user defined mesh structures. It is very common, for example, that mesh data structures contain problem specific information (local elasticity, permittivity, boundary conditions). User can use those enriched structures if they extend a limited number of functions.\nCharts: a concept designed after the differential geometric concept of a chart on a manifold. It allows for the construction of points in Euclidian space from a set of parameters and the other way around.\nNeighborhoods: a concept designed after the derivative of a chart as a map from the parametrising vector space to the tangent space of a point of the manifold. It allows querying for tangents, normal, and the Jacobian determinant for use in integration routines.","category":"page"},{"location":"#Mesh-Interface","page":"CompScienceMeshes.jl","title":"Mesh Interface","text":"","category":"section"},{"location":"","page":"CompScienceMeshes.jl","title":"CompScienceMeshes.jl","text":"This package introduces a minimalistic mesh interface and a standard implementation CompScienceMeshes.Mesh. The interface is defined by the semantics of the following functions:","category":"page"},{"location":"#Functions-to-query-a-mesh-for-its-characteristics","page":"CompScienceMeshes.jl","title":"Functions to query a mesh for its characteristics","text":"","category":"section"},{"location":"","page":"CompScienceMeshes.jl","title":"CompScienceMeshes.jl","text":"dimension(m::Mesh)\nuniversedimension(m::Mesh)\nvertextype\ncoordtype(m::Mesh)\nnumvertices\nnumcells","category":"page"},{"location":"#CompScienceMeshes.dimension-Tuple{Mesh}","page":"CompScienceMeshes.jl","title":"CompScienceMeshes.dimension","text":"dim = dimension(mesh)\n\nReturns the dimension of the mesh. Note that this is the dimension of the cells, not of the surrounding space.\n\n\n\n\n\ndimension(simplex)\n\nReturn the manifold dimension of the simplex.\n\n\n\n\n\n","category":"method"},{"location":"#CompScienceMeshes.universedimension-Tuple{Mesh}","page":"CompScienceMeshes.jl","title":"CompScienceMeshes.universedimension","text":"universedimension(mesh)\n\nReturns the dimension of the surrounding space. Equals the number of coordinates required to describe a vertex.\n\n\n\n\n\n","category":"method"},{"location":"#CompScienceMeshes.vertextype","page":"CompScienceMeshes.jl","title":"CompScienceMeshes.vertextype","text":"vt = vertextype(mesh)\n\nReturns type of the vertices used to define the cells of the mesh.\n\n\n\n\n\n","category":"function"},{"location":"#CompScienceMeshes.coordtype-Tuple{Mesh}","page":"CompScienceMeshes.jl","title":"CompScienceMeshes.coordtype","text":"coordtype(mesh)\n\nReturns eltype(vertextype(mesh))\n\n\n\n\n\ncoordtype(simplex)\n\nReturn coordinate type used by simplex.\n\n\n\n\n\n","category":"method"},{"location":"#CompScienceMeshes.numvertices","page":"CompScienceMeshes.jl","title":"CompScienceMeshes.numvertices","text":"numvertices(mesh)\n\nReturns the number of vertices in the mesh.\n\nNote: this is the number of vertices in the vertex buffer and might include floatin vertices or vertices not appearing in any cell. In other words the following is not necessarily true:\n\n    numvertices(mesh) == numcells(skeleton(mesh,0))\n\n\n\n\n\n","category":"function"},{"location":"#CompScienceMeshes.numcells","page":"CompScienceMeshes.jl","title":"CompScienceMeshes.numcells","text":"numcells(mesh)\n\nReturns the number of cells in the mesh.\n\n\n\n\n\n","category":"function"},{"location":"#Functions-to-iterate-over-the-mesh'-cells-and-the-underlying-point-set","page":"CompScienceMeshes.jl","title":"Functions to iterate over the mesh' cells and the underlying point set","text":"","category":"section"},{"location":"","page":"CompScienceMeshes.jl","title":"CompScienceMeshes.jl","text":"vertices\ncells","category":"page"},{"location":"#CompScienceMeshes.vertices","page":"CompScienceMeshes.jl","title":"CompScienceMeshes.vertices","text":"vertices(mesh)\n\nReturns an indexable iterable to the vertices of the mesh\n\n\n\n\n\n","category":"function"},{"location":"#CompScienceMeshes.cells","page":"CompScienceMeshes.jl","title":"CompScienceMeshes.cells","text":"cells(mesh)\n\nReturn an iterable collection containing the cells making up the mesh.\n\n\n\n\n\n","category":"function"},{"location":"#Functions-to-retrieve-adjacency-information-about-the-mesh","page":"CompScienceMeshes.jl","title":"Functions to retrieve adjacency information about the mesh","text":"","category":"section"},{"location":"","page":"CompScienceMeshes.jl","title":"CompScienceMeshes.jl","text":"skeleton\nconnectivity","category":"page"},{"location":"#CompScienceMeshes.skeleton","page":"CompScienceMeshes.jl","title":"CompScienceMeshes.skeleton","text":"skeleton(mesh, dim)\n\nReturns a mesh comprising the dim-dimensional sub cells of mesh. For example to retrieve the edges of a given surface mesh,\n\nedges = skelton(mesh, 1)\n\n\n\n\n\nskeleton(pred, mesh, dim)\n\nLike skeleton(mesh, dim), but only cells for which pred(cell) returns true are withheld.\n\n\n\n\n\n","category":"function"},{"location":"#CompScienceMeshes.connectivity","page":"CompScienceMeshes.jl","title":"CompScienceMeshes.connectivity","text":"connectivity(faces, cells, op=sign)\n\nCreate a sparse matrix D of size numcells(cells) by numcells(faces) that contiains the connectivity info of the mesh. In particular D[m,k] is op(r) where r is the local index of face k in cell m. The sign of r is positive or negative depending on the relative orientation of face k in cell m.\n\nFor op=sign, the matrix returned is the classic connectivity matrix, i.e. the graph version of the exterior derivative.\n\n\n\n\n\n","category":"function"},{"location":"example/#Computing-the-genus-of-a-punctured-plane","page":"Computing the genus of a punctured plane","title":"Computing the genus of a punctured plane","text":"","category":"section"},{"location":"example/","page":"Computing the genus of a punctured plane","title":"Computing the genus of a punctured plane","text":"In this example we will compute the genus of a punctured plane. In other words we are interested in the dimension of the 1st homology space.","category":"page"},{"location":"example/","page":"Computing the genus of a punctured plane","title":"Computing the genus of a punctured plane","text":"First we need to create the mesh. Typically this is done in an external mesher such as gmsh but here we will construct it from scratch.","category":"page"},{"location":"example/","page":"Computing the genus of a punctured plane","title":"Computing the genus of a punctured plane","text":"using CompScienceMeshes\n\nh = 1/6\nrect = meshrectangle(1.0, 1.0, h, 3)\nhole = meshrectangle(1/3, 1/3, h, 3)\ntranslate!(hole, point(1/3, 1/3, 0))\n\npred = overlap_gpredicate(hole)\nall_faces = submesh(c->!pred(chart(rect,c)), rect)\nnothing # hide","category":"page"},{"location":"example/","page":"Computing the genus of a punctured plane","title":"Computing the genus of a punctured plane","text":"Note that we started out creating a large rectangular mesh and a small one. Next we translate the small one to the center of the large one. We can use submesh to select the part of the mesh that does not coincide with the hole by providing an appropriate predicate.","category":"page"},{"location":"example/","page":"Computing the genus of a punctured plane","title":"Computing the genus of a punctured plane","text":"The tricky bit is that in order to get the correct number, we need to discard any vertices and edges that lie on the boundary of the structure. To do this we first retrieve a list of all edges and vertices by again calling skeleton with the appropriate dimension. In a next step we select out those vertices and edges that are not on the boundary.","category":"page"},{"location":"example/","page":"Computing the genus of a punctured plane","title":"Computing the genus of a punctured plane","text":"Note: overlap_predicate generates a predicate that takes cells of the same dimensionality as its argument. This means that we first need the 0-skeleton of the boundary before we can create a predicate that takes vertices of the original mesh.","category":"page"},{"location":"example/","page":"Computing the genus of a punctured plane","title":"Computing the genus of a punctured plane","text":"all_edges = skeleton(all_faces, 1)\nall_verts = skeleton(all_faces, 0)\n\nbnd_edges = boundary(all_faces)\nbnd_verts = skeleton(bnd_edges, 0)\n\n#onbnd1 = overlap_gpredicate(bnd_edges)\n#onbnd0 = overlap_gpredicate(bnd_verts)\n\ninterior_edges = submesh(!in(bnd_edges), all_edges)\ninterior_verts = submesh(!in(bnd_verts), all_verts)\nnothing # hide","category":"page"},{"location":"example/","page":"Computing the genus of a punctured plane","title":"Computing the genus of a punctured plane","text":"The set of interior_edges looks like this.","category":"page"},{"location":"example/","page":"Computing the genus of a punctured plane","title":"Computing the genus of a punctured plane","text":"(Image: )","category":"page"},{"location":"example/","page":"Computing the genus of a punctured plane","title":"Computing the genus of a punctured plane","text":"The co-boundary maps are simply the connectivity matrices between cells of the dimension 0-1 and 1-2, respectively. The genus can be computed by simply using the rank nullity theorem, but as part of this example we use the rank and nullspace on the connectivty matrices. This if desired can provide a representative of the cohomology space.","category":"page"},{"location":"example/","page":"Computing the genus of a punctured plane","title":"Computing the genus of a punctured plane","text":"D0 = connectivity(interior_verts, interior_edges)\nD1 = connectivity(interior_edges, all_faces)\n\nusing LinearAlgebra\nnullity(A) = size(A,2) - rank(A')\ngenus = nullity(Matrix(D1)) - rank(Matrix(D0))","category":"page"},{"location":"example/","page":"Computing the genus of a punctured plane","title":"Computing the genus of a punctured plane","text":"Of course we could have just computed Euler's number and deduced the genus from that:","category":"page"},{"location":"example/","page":"Computing the genus of a punctured plane","title":"Computing the genus of a punctured plane","text":" 1 - length(all_faces) + length(interior_edges) - length(interior_verts)","category":"page"}]
}
